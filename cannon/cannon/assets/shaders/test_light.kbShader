/// Renderer_Dx12.cpp
///
/// 2025 blk 1.0

struct SceneData {
	matrix modelMatrix;
	matrix world_matrix;
	matrix view_projection;
	float4 color;
	float4 spec;
	float4 camera;
	float4 time;
	matrix bones[128];
};

ConstantBuffer<SceneData> scene_constants[1024] : register(b0);

struct SceneIndex {
	uint index;
};
ConstantBuffer<SceneIndex> scene_index : register(b0, space1);

SamplerState SampleType : register(s0);
Texture2D color_tex[4] : register(t0);

/// VertexInput
struct VertexInput {
	float3 position		: POSITION;
	float2 uv			: TEXCOORD0;
};

/// PixelInput
struct PixelInput {
	float4 position		: SV_POSITION;
	float2 uv			: TEXCOORD0;
};

///	vertex_shader
PixelInput vertex_shader(VertexInput input) {
	SceneData matrixBuffer = scene_constants[scene_index.index];
	PixelInput output = (PixelInput)(0);
	output.position = float4(input.position.xyz, 1.0f);
	output.uv = input.uv;

	return output;
}

/// pixel_shader
float4 pixel_shader(PixelInput input) : SV_TARGET {
	const float3 light_dir = normalize(float3(-0.3f, 0.807f, -0.47f));

	SceneData scene_constant = scene_constants[scene_index.index];
	const float4 albedo =  color_tex[0].Sample(SampleType, input.uv);
	const float3 normal = color_tex[1].Sample(SampleType, input.uv).xyz * 2.f - 1.f;

	const float3 light_color = float3(0.7f, 0.8f, 0.83f);
	const float n_dot_l = smoothstep(0.5, 0.6, saturate(dot(normal, light_dir))) * 0.8 + 0.2f;

	// Spec
	const float3 diffuse = n_dot_l.xxx * albedo.xyz * light_color;

	// Spec
	/*const float3 to_cam = normalize(/*input.to_cam);
	const float3 r = 2 * n_dot_l * normal - light_dir;
	const float r_dot_v = saturate(dot(to_cam, r));
	const float highlight = pow(r_dot_v, input.spec.w);
	const float3 spec = input.spec.zzz * highlight.xxx * albedo.xyz;*/

	// Ambient
	const float3 ambient = float3(0.3f, 0.3f, 0.3f) * albedo.xyz;

	return float4(diffuse + ambient, 1.f);
}
