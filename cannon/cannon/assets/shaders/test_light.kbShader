/// Renderer_Dx12.cpp
///
/// 2025 blk 1.0

struct SceneData {
	matrix modelMatrix;
	matrix world_matrix;
	matrix view_projection;
	matrix inv_view_proj;
	float4 color;
	float4 spec;
	float4 camera;
	float4 time;
	matrix bones[128];
};

ConstantBuffer<SceneData> scene_constants[1024] : register(b0);

struct SceneIndex {
	uint index;
};
ConstantBuffer<SceneIndex> scene_index : register(b0, space1);

SamplerState SampleType : register(s0);
Texture2D color_tex[4] : register(t0);

/// VertexInput
struct VertexInput {
	float3 position		: POSITION;
	float2 uv			: TEXCOORD0;
};

/// PixelInput
struct PixelInput {
	float4 position		: SV_POSITION;
	float4 clip_position : POSITION;
	float2 uv			: TEXCOORD0;
};

///	vertex_shader
PixelInput vertex_shader(VertexInput input) {
	SceneData matrixBuffer = scene_constants[scene_index.index];
	PixelInput output = (PixelInput)(0);
	output.position = float4(input.position.xyz, 1.0f);
	output.clip_position = output.position;
	output.uv = input.uv;

	return output;
}

float3 apply_directional_light(
	const float3 light_dir,
	const float3 light_color,
	const float4 albedo,
	const float3 normal,
	const float3 spec,
	const float depth) {
	const float n_dot_l = smoothstep(0.5, 0.6, saturate(dot(normal, light_dir))) * 0.8 + 0.2f;
	const float3 diffuse = n_dot_l.xxx * albedo.xyz * light_color;

	return diffuse;
}

float3 apply_point_light(
	const float3 light_pos,
	const float3 light_color,
	const float light_radius,
	const float3 pixel_pos,
	const float4 albedo,
	const float3 normal,
	const float3 spec,
	const float depth) {

	float3 vec_to_light = light_pos - pixel_pos.xyz;
	float dist_to_light = length(vec_to_light);
	const float3 light_dir = normalize(vec_to_light);

	const float atten = 1.0f - saturate(dist_to_light / light_radius);
	const float n_dot_l = saturate(dot(normal, light_dir));

	return n_dot_l.xxx * atten * light_color * albedo.xyz;
}

/// pixel_shader
float4 pixel_shader(PixelInput input) : SV_TARGET {



/*
	if (length(light_pos - world_pos.xyz) < 5.1f) {
		return float4(1.0f, 0.0f, 0.0f, 1.0f);
	}*/
	const SceneData scene_constant = scene_constants[scene_index.index];
	const float4 albedo =  color_tex[0].Sample(SampleType, input.uv);
	const float3 normal = color_tex[1].Sample(SampleType, input.uv).xyz * 2.f - 1.f;
	const float3 spec = color_tex[2].Sample(SampleType, input.uv).xyz;
	const float depth = color_tex[3].Sample(SampleType, input.uv).r;

	float4 pixel_world_pos = float4(input.clip_position.xy, depth, 1);
	pixel_world_pos = mul( pixel_world_pos, scene_constants[0].inv_view_proj );
	pixel_world_pos /= pixel_world_pos.w;	float3 out_color = 0;

	// Directional Light
	{
		const float3 light_dir = normalize(float3(-0.3f, 0.807f, -0.47f));
		const float3 light_color = float3(0.7f, 0.8f, 0.83f);

		out_color = apply_directional_light(
			light_dir,
			light_color,
			albedo,
			normal,
			spec,
			depth
		);
	}

	// Point
	{
		const float3 light_pos = float3(-3.0f, 7.506421f, 1.000f);
		const float3 light_color = float3(1.0f, 0.0f, 0.f) * 5.0f;
		const float light_radius = 15.1;

		out_color += apply_point_light(
			light_pos,
			light_color,
			light_radius,
			pixel_world_pos.xyz,
			albedo,
			normal,
			spec,
			depth
		);

	}

	// Ambient
	const float3 ambient = float3(0.3f, 0.3f, 0.3f) * albedo.xyz;
	out_color += ambient;

	return float4(out_color, 1.f);
}
